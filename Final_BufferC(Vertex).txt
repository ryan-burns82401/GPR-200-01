#version 450
// #version 300 es

/*
	Author: Ryan Burns
	Class: GPR-200-01
	Assignment: Final
	Date: 12/1/20
	Last Modified: 12/14/20
	
	Credits: GLSL Starter Functions by Daniel S. Buckstein
			 (asPoint, asOffset)
*/

// BUFFER C (VERTEX)

// Part of the Project: Data Structures & Functions, Lighting,
//						Textures (Render Texture), Multipass

layout (location = 0) in vec4 aPosition;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec4 aTexCoord;

// Transform Uniforms
uniform mat4 uModelMat;
uniform mat4 uViewMat;
uniform mat4 uProjMat;
uniform mat4 uViewProjMat;

// Varying
out vec4 vTexCoord;

// used for Per-Vertex shading
out vec4 PerVertex;

//-----------------------------------
// asPoint: promote a 3D vector into a 4D vector representing a point (w=1)
//    point: input 3D vector
vec4 asPoint(in vec3 point)
{
    return vec4(point, 1.0);
}

// asOffset: promote a 3D vector into a 4D vector representing an offset (w=0)
//    offset: input 3D vector
vec4 asOffset(in vec3 offset)
{
    return vec4(offset, 0.0);
}

// sPointLight: structure for a point light
//	  center:    coordinates of the point light
//    color:     color of the point light
//    intensity: strength of the point light
struct sPointLight
{
    vec4 center;
    vec4 color;
    float intensity;
};

// initPointLight: initializes a point light given the parameters listed above
void initPointLight(out sPointLight light, in vec3 center, in vec4 color, in float intensity)
{
    light.center = asPoint(center);
    light.color = color;
    light.intensity = intensity;
}
//-----------------------------------

void main()
{
	// set gl_Position
	gl_Position = aPosition;
	
	// where a certain pixel will appear on the geometry
	// (for this pass: the full-screen quad)
	vTexCoord = aPosition * 0.5 + 0.5;
	
	// Final Position Pipeline
	// (modelViewMat -> pos_camera -> pos_clip)
	mat4 modelViewMat = uViewMat * uModelMat;
	vec4 pos_camera = modelViewMat * aPosition;
	vec4 pos_clip = uProjMat * pos_camera;
	gl_Position = pos_clip;
	
	//-----------------------------------
	// create point light
	sPointLight light_1;
	
	// initialize point light
	initPointLight(light_1, vec3(0.5, 1.0, 1.0), vec4(1.0, 0.2, 0.8, 1.0), 10.0);
	
	// LAMBERTIAN REFLECTANCE
	
	// displacement between the center of the light
    // and the surface of the sphere at the current point
    // NOT LENGTH
	vec3 light_vector = light_1.center.xyz - aPosition.xyz;
	
	// distance between the center of the light
    // and the surface of the sphere at the current point
    // DISTANCE <=> LENGTH
	float d = length(light_vector);
	
	// normal of the light vector
    // DISPLACEMENT / DISTANCE
	vec3 L = light_vector / d;
	
	// intensity of the light (from struct)
	float intensity = light_1.intensity;
	
	// attenuated intensity
	float aI = 1.0 / (1.0 + (d / intensity) + ((d * d) / (intensity * intensity)));
	
	// diffuse coefficient
	float dC = max(0.0, dot(aNormal, L));
	
	// diffuse intensity
	float dI = dC * aI;
	
	// without attenuation
	//PerVertex = vec4(dC, dC, dC, 1.0);
	// with attenuation
	//PerVertex = vec4(dI, dI, dI, 1.0);
	//-----------------------------------
	
	// diffuse reflection color (color of the surface)
    // currently set to white
    vec4 dRC = vec4(1.0, 1.0, 1.0, 1.0);
        
    // light color (from struct)
    vec4 light_color = light_1.color;
        
    // final surface color
    vec4 C = dI * dRC * light_color;
    
    //PerVertex = C;
	//-----------------------------------
	
	// PHONG REFLECTANCE
        
    // highlight exponent
    float a = 32.0;
        
    // displacement between the view position
    // and the surface of the sphere at the current point
    // NOT LENGTH
    vec3 view_vector = pos_camera.xyz - aPosition.xyz;
        
    // distance between the view position
    // and the surface of the sphere at the current point
    // DISTANCE <=> LENGTH
    float d2 = length(view_vector);
        
    // normal of the view vector
    // DISPLACEMENT / DISTANCE (same as 'normal' and 'L' above)
    vec3 V = view_vector / d2;
        
    // reflected light vector about the normal
    vec3 R = reflect(-L, aNormal);
        
    // specular coefficient (Phong)
    float sC = max(0.0, dot(V, R));
        
    // specular intensity (Phong)
    float sI = pow(sC, a);
    
    //PerVertex = vec4(sI, sI, sI, 1.0);
    //-----------------------------------
    
    // global ambient intensity
    float gaI = 1.0;
        
    // global ambient color
    vec4 gaC = vec4(0.6, 0.0, 0.5, 1.0);
        
    // specular reflection color
    // currently set to white
    vec4 sRC = vec4(1.0, 1.0, 1.0, 1.0);
        
    // final surface color
    vec4 C2 = (gaI * gaC) + (((dI * dRC) + (sI * sRC)) * light_color);
    
    //PerVertex = C2;
    //-----------------------------------
    
    // BLINN-PHONG REFLECTANCE
        
    // average of the light and view vectors
    vec3 halfway_vector = (light_vector + view_vector) * 0.5;
        
    // distance of the halfway vector
    float d3 = length(halfway_vector);
        
    // normal of the halfway vector
    vec3 H = halfway_vector / d3;
        
    // specular coefficient (Blinn-Phong)
    float sC2 = max(0.0, dot(aNormal, H));
        
    // specular intensity (Blinn-Phong)
    float sI2 = pow(sC2, (a * 4.0));
        
    // final surface color
    vec4 C3 = (gaI * gaC) + (((dI * dRC) + (sI2 * sRC)) * light_color);
        
    PerVertex = C3;
    //-----------------------------------
}