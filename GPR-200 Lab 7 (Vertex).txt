#version 450
// #version 300 es

/*
	Author: Ryan Burns
	Class: GPR-200-01
	Assignment: Lab 7
	Date: 10/30/20
	Last Modified: 11/5/20
	
	Credits: GLSL Starter Functions by Daniel S. Buckstein
			 (asPoint, asOffset)
*/

layout (location = 0) in vec4 aPosition;
layout (location = 1) in vec3 aNormal;
//layout (location = 2) in vec2 aTexcoord;
layout (location = 2) in vec4 aTexcoord;

// Transform Uniforms
uniform mat4 uModelMat;
uniform mat4 uViewMat;
uniform mat4 uProjMat;
uniform mat4 uViewProjMat;

// Varying
// Per-Vertex: final color
//out vec4 vColor;

// used for Per-Vertex shading
out vec4 PerVertex;

// Per-Fragment: individual components
out vec4 vNormal;
//out vec2 vTexcoord;
out vec4 vTexcoord;

//-----------------------------------
// asPoint: promote a 3D vector into a 4D vector representing a point (w=1)
//    point: input 3D vector
vec4 asPoint(in vec3 point)
{
    return vec4(point, 1.0);
}

// asOffset: promote a 3D vector into a 4D vector representing an offset (w=0)
//    offset: input 3D vector
vec4 asOffset(in vec3 offset)
{
    return vec4(offset, 0.0);
}

// sPointLight: structure for a point light
//	  center:    coordinates of the point light
//    color:     color of the point light
//    intensity: strength of the point light
struct sPointLight
{
    vec4 center;
    vec4 color;
    float intensity;
};

// initPointLight: initializes a point light given the parameters listed above
void initPointLight(out sPointLight light, in vec3 center, in vec4 color, in float intensity)
{
    light.center = asPoint(center);
    light.color = color;
    light.intensity = intensity;
}
//-----------------------------------

void main()
{
	// Required: set this value (gl_Position)
	//gl_Position = aPosition;
	
	// Position in World Space:
	//vec4 pos_world = uModelMat * aPosition;
	//gl_Position = pos_world;
	
	// Position in Camera Space:
	//vec4 pos_camera = uViewMat * pos_world;
	//vec4 pos_camera = uViewMat * uModelMat * aPosition;
	//gl_Position = pos_camera;
	
	// Position in Clip Space:
	//vec4 pos_clip = uViewProjMat * pos_world;
	//vec4 pos_clip = uProjMat * uViewMat * uModelMat * aPosition;
	
	// Final Position Pipeline:
	mat4 modelViewMat = uViewMat * uModelMat;
	vec4 pos_camera = modelViewMat * aPosition;
	vec4 pos_clip = uProjMat * pos_camera;
	gl_Position = pos_clip;
	
	// Normal Pipeline:
	//mat4 normalMatrix = inverse(transpose(modelViewMat));
	//vec4 norm_camera = modelViewMat * vec4(aNormal, 0.0);
	
	mat3 normalMatrix = inverse(transpose(mat3(modelViewMat)));
	vec3 norm_camera = normalMatrix * aNormal;
	
	// Texcoord Pipeline:
	// determines how the texture is displayed
	mat4 atlasMat = mat4(-1.0, 0.0, 0.0, 0.0,
						 0.0, 1.0, 0.0, 0.0,
						 0.0, 0.0, 1.0, 0.0,
						 0.0, 0.0, 0.0, 1.0);
	vec4 uv_atlas = atlasMat * aTexcoord;
	
	// Optional:
	//vColor = vec4(1.0, 0.5, 0.0, 1.0);
	//vColor = aPosition;
	//vColor = pos_camera;
	
	// Debug: output normal as color
	// Per-Vertex: output
	//vColor = vec4(aNormal * 0.5 + 0.5, 1.0);
	
	// Per-Fragment: outputs
	//vNormal = vec4(aNormal, 0.0);
	vNormal = vec4(norm_camera, 0.0);
	vTexcoord = uv_atlas;
	
	//gl_Position = uProjMat * modelViewMat * aTexcoord;
	//-----------------------------------
	
	// create point light
	sPointLight light_1;
	
	// initialize point light
	initPointLight(light_1, vec3(-1.5, -1.5, -1.5), vec4(1.0, 0.4, 0.2, 1.0), 10.0);
	
	// LAMBERTIAN REFLECTANCE
	
	// displacement between the center of the light
    // and the surface of the sphere at the current point
    // NOT LENGTH
	vec3 light_vector = light_1.center.xyz - aPosition.xyz;
	
	// distance between the center of the light
    // and the surface of the sphere at the current point
    // DISTANCE <=> LENGTH
	float d = length(light_vector);
	
	// normal of the light vector
    // DISPLACEMENT / DISTANCE
	vec3 L = light_vector / d;
	
	// intensity of the light (from struct)
	float intensity = light_1.intensity;
	
	// attenuated intensity
	float aI = 1.0 / (1.0 + (d / intensity) + ((d * d) / (intensity * intensity)));
	
	// diffuse coefficient
	float dC = max(0.0, dot(aNormal, L));
	
	// diffuse intensity
	float dI = dC * aI;
	
	// without attenuation
	PerVertex = vec4(dC, dC, dC, 1.0);
	// with attenuation
	PerVertex = vec4(dI, dI, dI, 1.0);
	//-----------------------------------
	
	// diffuse reflection color (color of the surface)
    // currently set to white
    vec4 dRC = vec4(1.0, 1.0, 1.0, 1.0);
    //vec4 dRC = earthTexture;
        
    // light color (from struct)
    vec4 light_color = light_1.color;
        
    // final surface color
    vec4 C = dI * dRC * light_color;
    
    PerVertex = C;
	//-----------------------------------
	
	// PHONG REFLECTANCE
        
    // highlight exponent
    float a = 32.0;
        
    // displacement between the view position
    // and the surface of the sphere at the current point
    // NOT LENGTH
    vec3 view_vector = pos_camera.xyz - aPosition.xyz;
        
    // distance between the view position
    // and the surface of the sphere at the current point
    // DISTANCE <=> LENGTH
    float d2 = length(view_vector);
        
    // normal of the view vector
    // DISPLACEMENT / DISTANCE (same as 'normal' and 'L' above)
    vec3 V = view_vector / d2;
        
    // reflected light vector about the normal
    vec3 R = reflect(-L, aNormal);
        
    // specular coefficient (Phong)
    float sC = max(0.0, dot(V, R));
        
    // specular intensity (Phong)
    float sI = pow(sC, a);
    
    PerVertex = vec4(sI, sI, sI, 1.0);
    //-----------------------------------
    
    // global ambient intensity
    float gaI = 1.0;
        
    // global ambient color
    vec4 gaC = vec4(0.5, 0.3, 0.1, 1.0);
        
    // specular reflection color
    // currently set to white
    vec4 sRC = vec4(1.0, 1.0, 1.0, 1.0);
        
    // final surface color
    vec4 C2 = (gaI * gaC) + (((dI * dRC) + (sI * sRC)) * light_color);
    
    PerVertex = C2;
    //-----------------------------------
    
    // BLINN-PHONG REFLECTANCE
        
    // average of the light and view vectors
    vec3 halfway_vector = (light_vector + view_vector) * 0.5;
        
    // distance of the halfway vector
    float d3 = length(halfway_vector);
        
    // normal of the halfway vector
    vec3 H = halfway_vector / d3;
        
    // specular coefficient (Blinn-Phong)
    float sC2 = max(0.0, dot(aNormal, H));
        
    // specular intensity (Blinn-Phong)
    float sI2 = pow(sC2, (a * 4.0));
        
    // final surface color
    vec4 C3 = (gaI * gaC) + (((dI * dRC) + (sI2 * sRC)) * light_color);
        
    PerVertex = C3;
    //-----------------------------------
}